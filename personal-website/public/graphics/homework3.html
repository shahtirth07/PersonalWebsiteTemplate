<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>3D Windmill Scene - Homework 3</title>

  <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
  <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
  <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
  <script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>

  <style>
    body { 
      font-family: system-ui, Arial, sans-serif; 
      margin: 0; 
      padding: 20px;
      background: #1a1a1a;
      color: white;
    }
    #controls { 
      margin-top: 10px; 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button { 
      padding: 8px 16px; 
      font-size: 14px; 
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #45a049;
    }
    #instructions {
      margin-bottom: 10px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body onload="main();">
  <div id="instructions">
    <strong>Controls:</strong> Use ↑↓ arrow keys to move forward/backward, ←→ to rotate camera.
  </div>
  <canvas id="webgl" width="1000" height="700"></canvas>
  <div id="controls">
    <button id="btnF">Forward</button>
    <button id="btnB">Back</button>
    <button id="btnL">Left</button>
    <button id="btnR">Right</button>
  </div>

<script>
const VSHADER_SRC = `
attribute vec3 a_Position;
attribute vec2 a_UV;
attribute vec3 a_Normal;

uniform mat4 u_Model, u_View, u_Proj;
uniform vec3 u_LightPos;
uniform vec3 u_ViewPos;

varying vec2 v_UV;
varying vec3 v_Normal;
varying vec3 v_FragPos;
varying vec3 v_LightPos;
varying vec3 v_ViewPos;

void main(){
  v_UV = a_UV;
  vec4 world = u_Model * vec4(a_Position, 1.0);
  v_FragPos = world.xyz;
  v_Normal = mat3(u_Model) * a_Normal;
  v_LightPos = u_LightPos;
  v_ViewPos = u_ViewPos;
  gl_Position = u_Proj * u_View * world;
}
`;

const FSHADER_BASIC = `
precision mediump float;
varying vec2 v_UV;
varying vec3 v_Normal;
varying vec3 v_FragPos;
varying vec3 v_LightPos;
varying vec3 v_ViewPos;

uniform vec3 u_Color;
uniform sampler2D u_Texture;
uniform bool u_UseTexture;

void main(){
  vec3 color = u_Color;
  if(u_UseTexture) {
    color = texture2D(u_Texture, v_UV).rgb;
  }
  
  gl_FragColor = vec4(color, 1.0);
}
`;

const FSHADER_FLOOR = `
precision mediump float;
varying vec2 v_UV;
varying vec3 v_Normal;
varying vec3 v_FragPos;
varying vec3 v_LightPos;
varying vec3 v_ViewPos;

uniform sampler2D u_Texture;
uniform bool u_UseTexture;
uniform float u_Time;

void main(){
  vec3 color;
  
  if(u_UseTexture) {
    vec2 tiledUV = v_UV * 4.0;
    color = texture2D(u_Texture, tiledUV).rgb;
  } else {
    color = vec3(0.5, 0.5, 0.5);
  }
  
  gl_FragColor = vec4(color, 1.0);
}
`;

function createCube() {
  const positions = new Float32Array([
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
    -1.0,  1.0,  1.0,
     1.0,  1.0,  1.0,
     1.0,  1.0, -1.0,
    -1.0, -1.0, -1.0,
     1.0, -1.0, -1.0,
     1.0, -1.0,  1.0,
    -1.0, -1.0,  1.0,
     1.0, -1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0,  1.0,  1.0,
     1.0, -1.0,  1.0,
    -1.0, -1.0, -1.0,
    -1.0, -1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0,  1.0, -1.0
  ]);

  const normals = new Float32Array([
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,
     0.0,  0.0,  1.0,
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,
     0.0,  0.0, -1.0,
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,
     0.0,  1.0,  0.0,
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,
     0.0, -1.0,  0.0,
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,
     1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0,
    -1.0,  0.0,  0.0
  ]);

  const uvs = new Float32Array([
    0.0, 0.0,
    1.0, 0.0,
    1.0, 1.0,
    0.0, 1.0,
    1.0, 0.0,
    1.0, 1.0,
    0.0, 1.0,
    0.0, 0.0,
    0.0, 1.0,
    0.0, 0.0,
    1.0, 0.0,
    1.0, 1.0,
    1.0, 1.0,
    0.0, 1.0,
    0.0, 0.0,
    1.0, 0.0,
    1.0, 0.0,
    1.0, 1.0,
    0.0, 1.0,
    0.0, 0.0,
    0.0, 0.0,
    1.0, 0.0,
    1.0, 1.0,
    0.0, 1.0
  ]);

  const indices = new Uint16Array([
    0,  1,  2,    0,  2,  3,
    4,  5,  6,    4,  6,  7,
    8,  9, 10,    8, 10, 11,
   12, 13, 14,   12, 14, 15,
   16, 17, 18,   16, 18, 19,
   20, 21, 22,   20, 22, 23
  ]);

  return { positions, normals, uvs, indices };
}

function compile(gl, type, src) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(sh));
  }
  return sh;
}

function linkProgram(gl, vsSrc, fsSrc) {
  const vs = compile(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = compile(gl, gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(p));
  }
  return p;
}

function createTexture(gl, imageData) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  return texture;
}

function createProceduralTexture(gl, size = 256, design = 'marble') {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  
  const imageData = ctx.createImageData(size, size);
  const data = imageData.data;
  
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const index = (y * size + x) * 4;
      let r, g, b;
      
      switch(design) {
        case 'marble':
          const marbleNoise = Math.sin(x * 0.1) * Math.cos(y * 0.1) + Math.random() * 0.3;
          const marbleIntensity = (marbleNoise + 1) * 0.5;
          r = Math.floor(240 * marbleIntensity);
          g = Math.floor(235 * marbleIntensity);
          b = Math.floor(220 * marbleIntensity);
          break;
          
        case 'brick':
          const brickX = Math.floor(x / 64);
          const brickY = Math.floor(y / 32);
          const offset = (brickY % 2) * 32;
          const inBrick = (x - offset) % 64 > 4 && y % 32 > 2;
          const brickNoise = Math.random() * 0.2;
          if (inBrick) {
            r = Math.floor((180 + brickNoise * 40) * 255 / 255);
            g = Math.floor((80 + brickNoise * 30) * 255 / 255);
            b = Math.floor((40 + brickNoise * 20) * 255 / 255);
          } else {
            r = Math.floor((120 + brickNoise * 20) * 255 / 255);
            g = Math.floor((100 + brickNoise * 15) * 255 / 255);
            b = Math.floor((80 + brickNoise * 15) * 255 / 255);
          }
          break;
          
        case 'hexagon':
          const hexSize = 40;
          const hexX = x / hexSize;
          const hexY = y / hexSize;
          const hexDist = Math.sqrt((hexX - Math.floor(hexX + 0.5)) ** 2 + (hexY - Math.floor(hexY + 0.5)) ** 2);
          const inHex = hexDist < 0.4;
          const hexNoise = Math.random() * 0.3;
          if (inHex) {
            r = Math.floor((100 + hexNoise * 50) * 255 / 255);
            g = Math.floor((150 + hexNoise * 40) * 255 / 255);
            b = Math.floor((200 + hexNoise * 30) * 255 / 255);
          } else {
            r = Math.floor((50 + hexNoise * 30) * 255 / 255);
            g = Math.floor((50 + hexNoise * 30) * 255 / 255);
            b = Math.floor((80 + hexNoise * 40) * 255 / 255);
          }
          break;
          
        case 'circuit':
          const circuitNoise = Math.random() * 0.4;
          const lineX = x % 32 < 2 || x % 32 > 30;
          const lineY = y % 32 < 2 || y % 32 > 30;
          if (lineX || lineY) {
            r = Math.floor((0 + circuitNoise * 100) * 255 / 255);
            g = Math.floor((255 + circuitNoise * 50) * 255 / 255);
            b = Math.floor((100 + circuitNoise * 80) * 255 / 255);
          } else {
            r = Math.floor((20 + circuitNoise * 30) * 255 / 255);
            g = Math.floor((20 + circuitNoise * 30) * 255 / 255);
            b = Math.floor((40 + circuitNoise * 40) * 255 / 255);
          }
          break;
          
        case 'wood':
        default:
          const checker = Math.floor(x / 32) % 2 === Math.floor(y / 32) % 2;
          const woodNoise = Math.random() * 0.3;
          if (checker) {
            r = Math.floor((139 + woodNoise * 50) * 255 / 255);
            g = Math.floor((69 + woodNoise * 30) * 255 / 255);
            b = Math.floor((19 + woodNoise * 20) * 255 / 255);
          } else {
            r = Math.floor((205 + woodNoise * 50) * 255 / 255);
            g = Math.floor((133 + woodNoise * 30) * 255 / 255);
            b = Math.floor((63 + woodNoise * 20) * 255 / 255);
          }
          break;
      }
      
      data[index] = r;
      data[index + 1] = g;
      data[index + 2] = b;
      data[index + 3] = 255;
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
  return createTexture(gl, canvas);
}

function main() {
  const canvas = document.getElementById('webgl');
  const gl = getWebGLContext(canvas);
  if (!gl) {
    alert('WebGL failed');
    return;
  }

  gl.clearColor(0.1, 0.1, 0.2, 1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.disable(gl.CULL_FACE);

  const basicProg = linkProgram(gl, VSHADER_SRC, FSHADER_BASIC);
  const floorProg = linkProgram(gl, VSHADER_SRC, FSHADER_FLOOR);

  const cube = createCube();

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, cube.positions, gl.STATIC_DRAW);

  const normalBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuf);
  gl.bufferData(gl.ARRAY_BUFFER, cube.normals, gl.STATIC_DRAW);

  const uvBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
  gl.bufferData(gl.ARRAY_BUFFER, cube.uvs, gl.STATIC_DRAW);

  const indexBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube.indices, gl.STATIC_DRAW);

  const floorTexture = createProceduralTexture(gl, 256, 'marble');

  const proj = new Matrix4();
  const view = new Matrix4();
  const model = new Matrix4();

  const camera = {
    x: 0, y: 2, z: 8,
    yaw: 0, pitch: 0
  };

  function updateProjection() {
    proj.setPerspective(45, canvas.width / canvas.height, 0.1, 100);
  }

  function updateView() {
    const cosYaw = Math.cos(camera.yaw);
    const sinYaw = Math.sin(camera.yaw);
    const cosPitch = Math.cos(camera.pitch);
    const sinPitch = Math.sin(camera.pitch);

    const forward = {
      x: sinYaw * cosPitch,
      y: -sinPitch,
      z: cosYaw * cosPitch
    };

    const right = {
      x: cosYaw,
      y: 0,
      z: -sinYaw
    };

    const up = {
      x: sinYaw * sinPitch,
      y: cosPitch,
      z: cosYaw * sinPitch
    };

    const target = {
      x: camera.x + forward.x,
      y: camera.y + forward.y,
      z: camera.z + forward.z
    };

    view.setLookAt(
      camera.x, camera.y, camera.z,
      target.x, target.y, target.z,
      up.x, up.y, up.z
    );
  }

  updateProjection();
  updateView();

  const windmillParts = [
    { name: 'shaft', color: [0.8, 0.2, 0.2], scale: [0.3, 4.0, 0.3], pos: [0, 0, 0] },
    { name: 'hub', color: [0.8, 0.2, 0.2], scale: [0.3, 0.3, 0.3], pos: [0, 2.5, 0.8] },
    { name: 'blade1', color: [0.2, 0.8, 0.2], scale: [2.0, 0.2, 0.2], pos: [0, 2.5, 1.8], angle: 0 },
    { name: 'blade2', color: [0.8, 0.8, 0.2], scale: [2.0, 0.2, 0.2], pos: [0, 2.5, 1.9], angle: 90 },
    { name: 'blade3', color: [0.2, 0.2, 0.8], scale: [2.0, 0.2, 0.2], pos: [0, 2.5, 2.0], angle: 180 },
    { name: 'blade4', color: [0.2, 0.8, 0.8], scale: [2.0, 0.2, 0.2], pos: [0, 2.5, 2.1], angle: 270 }
  ];

  function bindAttribs(program) {
    gl.useProgram(program);
    
    const aPos = gl.getAttribLocation(program, 'a_Position');
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPos);

    const aNormal = gl.getAttribLocation(program, 'a_Normal');
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuf);
    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aNormal);

    const aUV = gl.getAttribLocation(program, 'a_UV');
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
    gl.vertexAttribPointer(aUV, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aUV);
  }

  function getUniforms(program) {
    return {
      u_Model: gl.getUniformLocation(program, 'u_Model'),
      u_View: gl.getUniformLocation(program, 'u_View'),
      u_Proj: gl.getUniformLocation(program, 'u_Proj'),
      u_Color: gl.getUniformLocation(program, 'u_Color'),
      u_Texture: gl.getUniformLocation(program, 'u_Texture'),
      u_UseTexture: gl.getUniformLocation(program, 'u_UseTexture'),
      u_Time: gl.getUniformLocation(program, 'u_Time')
    };
  }

  const basicUniforms = getUniforms(basicProg);
  const floorUniforms = getUniforms(floorProg);

  function moveForward() {
    const cosYaw = Math.cos(camera.yaw);
    const sinYaw = Math.sin(camera.yaw);
    camera.x += sinYaw * 0.5;
    camera.z += cosYaw * 0.5;
    updateView();
  }

  function moveBackward() {
    const cosYaw = Math.cos(camera.yaw);
    const sinYaw = Math.sin(camera.yaw);
    camera.x -= sinYaw * 0.5;
    camera.z -= cosYaw * 0.5;
    updateView();
  }

  function rotateLeft() {
    camera.yaw += 0.1;
    updateView();
  }

  function rotateRight() {
    camera.yaw -= 0.1;
    updateView();
  }

  document.getElementById('btnF').onclick = moveForward;
  document.getElementById('btnB').onclick = moveBackward;
  document.getElementById('btnL').onclick = rotateLeft;
  document.getElementById('btnR').onclick = rotateRight;

  window.addEventListener('keydown', (e) => {
    switch(e.key) {
      case 'ArrowUp': moveForward(); break;
      case 'ArrowDown': moveBackward(); break;
      case 'ArrowLeft': rotateLeft(); break;
      case 'ArrowRight': rotateRight(); break;
    }
  });

  let time = 0;
  function draw() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    time += 0.016;

    bindAttribs(basicProg);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
    
    gl.uniformMatrix4fv(basicUniforms.u_View, false, view.elements);
    gl.uniformMatrix4fv(basicUniforms.u_Proj, false, proj.elements);
    gl.uniform1i(basicUniforms.u_UseTexture, false);

    windmillParts.forEach((part, index) => {
      model.setIdentity();
      
      if (part.name === 'shaft' || part.name === 'hub') {
        model.translate(part.pos[0], part.pos[1], part.pos[2])
              .scale(part.scale[0], part.scale[1], part.scale[2]);
      } else {
        const bladeRotation = time * 2.0 + part.angle * Math.PI / 180;
        model.translate(part.pos[0], part.pos[1], part.pos[2])
              .rotate(bladeRotation * 180 / Math.PI, 0, 0, 1)
              .scale(part.scale[0], part.scale[1], part.scale[2])
              .translate(1.0, 0, 0);
      }
      
      gl.uniformMatrix4fv(basicUniforms.u_Model, false, model.elements);
      gl.uniform3f(basicUniforms.u_Color, part.color[0], part.color[1], part.color[2]);
      gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);
    });

    bindAttribs(floorProg);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf);
    
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, floorTexture);
    
    gl.uniformMatrix4fv(floorUniforms.u_View, false, view.elements);
    gl.uniformMatrix4fv(floorUniforms.u_Proj, false, proj.elements);
    gl.uniform1f(floorUniforms.u_Time, time);
    gl.uniform1i(floorUniforms.u_Texture, 0);
    gl.uniform1i(floorUniforms.u_UseTexture, true);

    model.setIdentity()
          .translate(0, -1.5, 0)
          .rotate(-90, 1, 0, 0)
          .scale(20, 20, 0.1);
    gl.uniformMatrix4fv(floorUniforms.u_Model, false, model.elements);
    gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);

    requestAnimationFrame(draw);
  }

  draw();
}

</script>
</body>
</html>
