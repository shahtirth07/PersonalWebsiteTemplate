<!DOCTYPE html>
<html>

<head>
<title>WebGL Scene with Three Shapes and Lighting</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>

<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f0f0f0;
    }
    canvas {
        border: 2px solid #333;
        margin: 20px 0;
    }
    .controls {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 10px 0;
    }
    .control-group {
        margin: 15px 0;
    }
    label {
        display: inline-block;
        width: 120px;
        font-weight: bold;
    }
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    .value {
        display: inline-block;
        width: 50px;
        text-align: center;
        background-color: #e0e0e0;
        padding: 2px 5px;
        border-radius: 3px;
    }
</style>

<script>

var VSHADER_SOURCE =
    `attribute vec4 a_Position; 
    attribute vec4 a_Color; 
    attribute vec4 a_Normal; 
    attribute vec2 a_UV; 
    uniform mat4 u_ModelMatrix; 
    uniform mat4 u_ViewMatrix; 
    uniform mat4 u_ProjMatrix;
    uniform mat4 u_NormalMatrix;
    uniform vec3 u_CameraPosition;
    varying vec4 v_Position;
    varying vec4 v_Color;
    varying vec3 v_Normal;
    varying vec2 v_UV;
    void main() { 
        gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
        v_Position = u_ModelMatrix * a_Position;
        v_Color = a_Color;
        v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));
        v_UV = a_UV;
    }`;

var FSHADER_SOURCE =
    `precision mediump float;
    varying vec4 v_Position; 
    varying vec4 v_Color; 
    varying vec3 v_Normal;
    varying vec2 v_UV;
    uniform float u_Time; 
    uniform vec3 u_Light1Position;
    uniform vec3 u_Light1Color;
    uniform vec3 u_Light2Position;
    uniform vec3 u_Light2Color;
    uniform vec3 u_AmbientLight;
    uniform vec3 u_CameraPosition;
    uniform sampler2D u_Sampler;
    uniform bool u_UseReflection;
    uniform bool u_UseProcedural;
    
    float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }
    
    float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }
    
    void main() { 
        vec3 normal = normalize(v_Normal);
        vec3 viewDir = normalize(u_CameraPosition - v_Position.xyz);
        
        vec3 albedo = v_Color.rgb;
        
        if (u_UseReflection && v_Position.y < -1.5) {
            vec2 uv = fract(v_UV * 4.0);
            albedo = texture2D(u_Sampler, uv).rgb;
        }
        
        vec3 ambient = u_AmbientLight * albedo;
        
        vec3 light1Direction = normalize(u_Light1Position - v_Position.xyz);
        float nDotL1 = max(dot(light1Direction, normal), 0.0);
        vec3 diffuse1 = u_Light1Color * albedo * nDotL1;
        
        vec3 reflect1 = reflect(-light1Direction, normal);
        float spec1 = pow(max(dot(viewDir, reflect1), 0.0), 32.0);
        vec3 specular1 = u_Light1Color * spec1;
        
        vec3 light2Direction = normalize(u_Light2Position - v_Position.xyz);
        float nDotL2 = max(dot(light2Direction, normal), 0.0);
        vec3 diffuse2 = u_Light2Color * albedo * nDotL2;
        
        vec3 reflect2 = reflect(-light2Direction, normal);
        float spec2 = pow(max(dot(viewDir, reflect2), 0.0), 32.0);
        vec3 specular2 = u_Light2Color * spec2;
        
        vec3 finalColor = ambient + diffuse1 + diffuse2 + specular1 + specular2;
        
        if (u_UseReflection) {
            vec3 V = normalize(u_CameraPosition - v_Position.xyz);
            vec3 reflectview = normalize(reflect(V, normal));
            float u = -(v_Position.y + 2.0) / reflectview.y;
            vec2 reflmapresult = v_Position.xz - u * reflectview.xz;
            vec2 tiledReflUV = fract(reflmapresult * 0.25);
            vec4 texcolor = texture2D(u_Sampler, tiledReflUV) * pow(max(-normal.y, 0.0), 2.0);
            finalColor += texcolor.rgb;
        }
        
        if (u_UseProcedural) {
            vec2 st = v_UV;
            float n = noise(st * 10.0);
            if (n > 0.7) {
                discard;
            }
        }
        
        gl_FragColor = vec4(finalColor, v_Color.a);
    }`;

var sphereData, coneData, cylinderData, floorData;
var gl;
var light1Position = [2.0, 2.0, 2.0];
var light1Color = [1.0, 1.0, 1.0];
var light2Position = [-2.0, 2.0, -2.0];
var light2Color = [1.0, 0.5, 0.0];
var ambientLight = [0.2, 0.2, 0.2];

var cameraPosition = [0, 2, 8];
var cameraLookAt = [0, 0, 0];
var cameraUp = [0, 1, 0];
var moveSpeed = 0.1;
var lookSpeed = 0.05;

var texture;
var useReflection = false;
var useProcedural = false;

function main(){
    console.log("WebGL Scene Starting");
    var canvas = document.getElementById('webgl');
    gl = getWebGLContext(canvas);

    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);
    gl.useProgram(gl.program);

    gl.enable(gl.DEPTH_TEST);

    sphereData = createSphere(16);
    coneData = createCone(16);
    cylinderData = createCylinder(16);
    floorData = createFloor();
    
    loadTexture();

    var modelMatrix = new Matrix4();
    var viewMatrix = new Matrix4();
    var projMatrix = new Matrix4();
    var normalMatrix = new Matrix4();
    var u_ModelMatrix = gl.getUniformLocation(gl.program, 'u_ModelMatrix');
    var u_ViewMatrix = gl.getUniformLocation(gl.program, 'u_ViewMatrix');
    var u_ProjMatrix = gl.getUniformLocation(gl.program, 'u_ProjMatrix');
    var u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix');

    var u_Light1Position = gl.getUniformLocation(gl.program, 'u_Light1Position');
    var u_Light1Color = gl.getUniformLocation(gl.program, 'u_Light1Color');
    var u_Light2Position = gl.getUniformLocation(gl.program, 'u_Light2Position');
    var u_Light2Color = gl.getUniformLocation(gl.program, 'u_Light2Color');
    var u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
    var u_CameraPosition = gl.getUniformLocation(gl.program, 'u_CameraPosition');
    var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
    var u_UseReflection = gl.getUniformLocation(gl.program, 'u_UseReflection');
    var u_UseProcedural = gl.getUniformLocation(gl.program, 'u_UseProcedural');

    var TIME = 0.0;
    var u_Time = gl.getUniformLocation(gl.program, 'u_Time');
    setupSliderListeners();
    setupKeyboardControls();

    var tick = function() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        TIME += 0.01;
        gl.uniform1f(u_Time, TIME);

        viewMatrix.setLookAt(cameraPosition[0], cameraPosition[1], cameraPosition[2], 
                           cameraLookAt[0], cameraLookAt[1], cameraLookAt[2], 
                           cameraUp[0], cameraUp[1], cameraUp[2]);
        gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements);

        projMatrix.setPerspective(30, canvas.width / canvas.height, 1, 100);
        gl.uniformMatrix4fv(u_ProjMatrix, false, projMatrix.elements);

        gl.uniform3fv(u_CameraPosition, cameraPosition);
        gl.uniform3fv(u_Light1Position, light1Position);
        gl.uniform3fv(u_Light1Color, light1Color);
        gl.uniform3fv(u_Light2Position, light2Position);
        gl.uniform3fv(u_Light2Color, light2Color);
        gl.uniform3fv(u_AmbientLight, ambientLight);
        
        if (texture) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(u_Sampler, 0);
        }
        gl.uniform1i(u_UseReflection, useReflection);
        gl.uniform1i(u_UseProcedural, useProcedural);

        modelMatrix.setIdentity();
        modelMatrix.translate(0, -2, 0);
        modelMatrix.scale(10, 1, 10);
        gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();
        gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements);
        useReflection = true;
        useProcedural = false;
        gl.uniform1i(u_UseReflection, useReflection);
        gl.uniform1i(u_UseProcedural, useProcedural);
        drawShape(gl, floorData);

        modelMatrix.setIdentity();
        modelMatrix.translate(-2, 0, 0);
        modelMatrix.rotate(TIME * 0.5, 0, 1, 0);
        gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();
        gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements);
        useReflection = true;
        useProcedural = false;
        gl.uniform1i(u_UseReflection, useReflection);
        gl.uniform1i(u_UseProcedural, useProcedural);
        drawShape(gl, sphereData);

        modelMatrix.setIdentity();
        modelMatrix.translate(0, 0, 0);
        modelMatrix.rotate(TIME * 0.3, 0, 1, 0);
        modelMatrix.rotate(Math.PI/4, 1, 0, 0);
        gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();
        gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements);
        useReflection = true;
        useProcedural = false;
        gl.uniform1i(u_UseReflection, useReflection);
        gl.uniform1i(u_UseProcedural, useProcedural);
        drawShape(gl, coneData);

        modelMatrix.setIdentity();
        modelMatrix.translate(2, 0, 0);
        modelMatrix.rotate(TIME * 0.7, 0, 1, 0);
        modelMatrix.rotate(Math.PI/6, 1, 0, 0);
        gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();
        gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements);
        useReflection = true;
        useProcedural = true;
        gl.uniform1i(u_UseReflection, useReflection);
        gl.uniform1i(u_UseProcedural, useProcedural);
        drawShape(gl, cylinderData);

        requestAnimationFrame(tick, canvas);
    };
    tick();
}

function createSphere(stacks) {
    var SPHERE_DIV = stacks;
    var i, ai, si, ci;
    var j, aj, sj, cj;
    var p1, p2;

    var positions = [];
    var indices = [];
    var colors = [];
    var uvs = [];

    for (j = 0; j <= SPHERE_DIV; j++) {
        aj = j * Math.PI / SPHERE_DIV;
        sj = Math.sin(aj);
        cj = Math.cos(aj);
        for (i = 0; i <= SPHERE_DIV; i++) {
            ai = i * 2 * Math.PI / SPHERE_DIV;
            si = Math.sin(ai);
            ci = Math.cos(ai);

            positions.push(si * sj);
            positions.push(cj);
            positions.push(ci * sj);

            colors.push(0.8, 0.2, 0.2);

            uvs.push(i / SPHERE_DIV);
            uvs.push(j / SPHERE_DIV);
        }
    }

    for (j = 0; j < SPHERE_DIV; j++) {
        for (i = 0; i < SPHERE_DIV; i++) {
            p1 = j * (SPHERE_DIV + 1) + i;
            p2 = p1 + (SPHERE_DIV + 1);

            indices.push(p1);
            indices.push(p2);
            indices.push(p1 + 1);

            indices.push(p1 + 1);
            indices.push(p2);
            indices.push(p2 + 1);
        }
    }

    return {
        positions: new Float32Array(positions),
        indices: new Uint16Array(indices),
        colors: new Float32Array(colors),
        uvs: new Float32Array(uvs),
        indexCount: indices.length
    };
}

function createCone(stacks) {
    var CONE_DIV = stacks;
    var i, ai, si, ci;
    var j, aj, sj, cj;
    var p1, p2;

    var positions = [];
    var indices = [];
    var colors = [];
    var uvs = [];

    for (j = 0; j <= CONE_DIV; j++) {
        aj = j * Math.PI / CONE_DIV;
        sj = Math.sin(aj);
        cj = Math.cos(aj);
        for (i = 0; i <= CONE_DIV; i++) {
            ai = i * 2 * Math.PI / CONE_DIV;
            si = Math.sin(ai);
            ci = Math.cos(ai);

            var stackRadius = 1.0 - (j / CONE_DIV);
            var height = (j / CONE_DIV) * 2.0 - 1.0;
            
            positions.push(si * stackRadius);
            positions.push(height);
            positions.push(ci * stackRadius);

            colors.push(0.2, 0.8, 0.2);

            uvs.push(i / CONE_DIV);
            uvs.push(j / CONE_DIV);
        }
    }

    for (j = 0; j < CONE_DIV; j++) {
        for (i = 0; i < CONE_DIV; i++) {
            p1 = j * (CONE_DIV + 1) + i;
            p2 = p1 + (CONE_DIV + 1);

            indices.push(p1);
            indices.push(p2);
            indices.push(p1 + 1);

            indices.push(p1 + 1);
            indices.push(p2);
            indices.push(p2 + 1);
        }
    }

    var baseCenterIndex = positions.length / 3;
    positions.push(0, -1, 0);
    colors.push(0.2, 0.8, 0.2);
    uvs.push(0.5, 0.5);

    for (i = 0; i <= CONE_DIV; i++) {
        ai = i * 2 * Math.PI / CONE_DIV;
        si = Math.sin(ai);
        ci = Math.cos(ai);
        
        positions.push(si, -1, ci);
        colors.push(0.2, 0.8, 0.2);
        uvs.push((si + 1) / 2, (ci + 1) / 2);
    }

    for (i = 0; i < CONE_DIV; i++) {
        indices.push(baseCenterIndex);
        indices.push(baseCenterIndex + 1 + i);
        indices.push(baseCenterIndex + 1 + ((i + 1) % (CONE_DIV + 1)));
    }

    return {
        positions: new Float32Array(positions),
        indices: new Uint16Array(indices),
        colors: new Float32Array(colors),
        uvs: new Float32Array(uvs),
        indexCount: indices.length
    };
}

function createCylinder(stacks) {
    var CYLINDER_DIV = stacks;
    var i, ai, si, ci;
    var j, aj, sj, cj;
    var p1, p2;

    var positions = [];
    var indices = [];
    var colors = [];
    var uvs = [];

    for (j = 0; j <= CYLINDER_DIV; j++) {
        aj = j * Math.PI / CYLINDER_DIV;
        sj = Math.sin(aj);
        cj = Math.cos(aj);
        for (i = 0; i <= CYLINDER_DIV; i++) {
            ai = i * 2 * Math.PI / CYLINDER_DIV;
            si = Math.sin(ai);
            ci = Math.cos(ai);

            var stackRadius = 1.0;
            var height = (j / CYLINDER_DIV) * 2.0 - 1.0;
            
            positions.push(si * stackRadius);
            positions.push(height);
            positions.push(ci * stackRadius);

            colors.push(0.2, 0.2, 0.8);

            uvs.push(i / CYLINDER_DIV);
            uvs.push(j / CYLINDER_DIV);
        }
    }

    for (j = 0; j < CYLINDER_DIV; j++) {
        for (i = 0; i < CYLINDER_DIV; i++) {
            p1 = j * (CYLINDER_DIV + 1) + i;
            p2 = p1 + (CYLINDER_DIV + 1);

            indices.push(p1);
            indices.push(p2);
            indices.push(p1 + 1);

            indices.push(p1 + 1);
            indices.push(p2);
            indices.push(p2 + 1);
        }
    }

    var bottomCenterIndex = positions.length / 3;
    positions.push(0, -1, 0);
    colors.push(0.2, 0.2, 0.8);
    uvs.push(0.5, 0.5);

    for (i = 0; i <= CYLINDER_DIV; i++) {
        ai = i * 2 * Math.PI / CYLINDER_DIV;
        si = Math.sin(ai);
        ci = Math.cos(ai);
        
        positions.push(si, -1, ci);
        colors.push(0.2, 0.2, 0.8);
        uvs.push((si + 1) / 2, (ci + 1) / 2);
    }

    for (i = 0; i < CYLINDER_DIV; i++) {
        indices.push(bottomCenterIndex);
        indices.push(bottomCenterIndex + 1 + i);
        indices.push(bottomCenterIndex + 1 + ((i + 1) % (CYLINDER_DIV + 1)));
    }

    var topCenterIndex = positions.length / 3;
    positions.push(0, 1, 0);
    colors.push(0.2, 0.2, 0.8);
    uvs.push(0.5, 0.5);

    for (i = 0; i <= CYLINDER_DIV; i++) {
        ai = i * 2 * Math.PI / CYLINDER_DIV;
        si = Math.sin(ai);
        ci = Math.cos(ai);
        
        positions.push(si, 1, ci);
        colors.push(0.2, 0.2, 0.8);
        uvs.push((si + 1) / 2, (ci + 1) / 2);
    }

    for (i = 0; i < CYLINDER_DIV; i++) {
        indices.push(topCenterIndex);
        indices.push(topCenterIndex + 1 + ((i + 1) % (CYLINDER_DIV + 1)));
        indices.push(topCenterIndex + 1 + i);
    }

    return {
        positions: new Float32Array(positions),
        indices: new Uint16Array(indices),
        colors: new Float32Array(colors),
        uvs: new Float32Array(uvs),
        indexCount: indices.length
    };
}

function createFloor() {
    var positions = [
        -1, 0, -1,
         1, 0, -1,
         1, 0,  1,
        -1, 0,  1
    ];
    
    var indices = [
        0, 1, 2,
        0, 2, 3
    ];
    
    var colors = [
        0.8, 0.8, 0.8,
        0.8, 0.8, 0.8,
        0.8, 0.8, 0.8,
        0.8, 0.8, 0.8
    ];
    
    var uvs = [
        0, 0,
        1, 0,
        1, 1,
        0, 1
    ];
    
    var normals = [
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0
    ];
    
    return {
        positions: new Float32Array(positions),
        indices: new Uint16Array(indices),
        colors: new Float32Array(colors),
        uvs: new Float32Array(uvs),
        normals: new Float32Array(normals),
        indexCount: indices.length
    };
}

function drawShape(gl, shapeData) {
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shapeData.positions, gl.STATIC_DRAW);
    var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
    gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_Position);

    var normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    var normalData = shapeData.normals || shapeData.positions;
    gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
    var a_Normal = gl.getAttribLocation(gl.program, 'a_Normal');
    gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_Normal);

    var colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shapeData.colors, gl.STATIC_DRAW);
    var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
    gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_Color);

    var uvBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shapeData.uvs, gl.STATIC_DRAW);
    var a_UV = gl.getAttribLocation(gl.program, 'a_UV');
    gl.vertexAttribPointer(a_UV, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_UV);

    var indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shapeData.indices, gl.STATIC_DRAW);

    gl.drawElements(gl.TRIANGLES, shapeData.indexCount, gl.UNSIGNED_SHORT, 0);
}

function loadTexture() {
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    
    var image = new Image();
    image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    };
    
    image.src = 'data:image/jpeg;base64,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';}

function setupKeyboardControls() {
    document.addEventListener('keydown', function(event) {
        var forward = [cameraLookAt[0] - cameraPosition[0], 
                      cameraLookAt[1] - cameraPosition[1], 
                      cameraLookAt[2] - cameraPosition[2]];
        var length = Math.sqrt(forward[0]*forward[0] + forward[1]*forward[1] + forward[2]*forward[2]);
        forward = [forward[0]/length, forward[1]/length, forward[2]/length];
        
        var right = [forward[2], 0, -forward[0]];
        var up = [0, 1, 0];
        
        switch(event.key) {
            case 'w':
                cameraPosition[0] += forward[0] * moveSpeed;
                cameraPosition[1] += forward[1] * moveSpeed;
                cameraPosition[2] += forward[2] * moveSpeed;
                cameraLookAt[0] += forward[0] * moveSpeed;
                cameraLookAt[1] += forward[1] * moveSpeed;
                cameraLookAt[2] += forward[2] * moveSpeed;
                break;
            case 's':
                cameraPosition[0] -= forward[0] * moveSpeed;
                cameraPosition[1] -= forward[1] * moveSpeed;
                cameraPosition[2] -= forward[2] * moveSpeed;
                cameraLookAt[0] -= forward[0] * moveSpeed;
                cameraLookAt[1] -= forward[1] * moveSpeed;
                cameraLookAt[2] -= forward[2] * moveSpeed;
                break;
            case 'ArrowUp':
                cameraLookAt[1] += lookSpeed;
                break;
            case 'ArrowDown':
                cameraLookAt[1] -= lookSpeed;
                break;
            case 'ArrowLeft':
                cameraLookAt[0] -= right[0] * lookSpeed;
                cameraLookAt[2] -= right[2] * lookSpeed;
                break;
            case 'ArrowRight':
                cameraLookAt[0] += right[0] * lookSpeed;
                cameraLookAt[2] += right[2] * lookSpeed;
                break;
        }
    });
}

function toggleReflection() {
    useReflection = !useReflection;
}

function toggleProcedural() {
    useProcedural = !useProcedural;
}

function setupSliderListeners() {
    document.getElementById('lightX').addEventListener('input', function(e) {
        light1Position[0] = parseFloat(e.target.value);
        document.getElementById('lightXValue').textContent = e.target.value;
    });

    document.getElementById('lightY').addEventListener('input', function(e) {
        light1Position[1] = parseFloat(e.target.value);
        document.getElementById('lightYValue').textContent = e.target.value;
    });

    document.getElementById('lightZ').addEventListener('input', function(e) {
        light1Position[2] = parseFloat(e.target.value);
        document.getElementById('lightZValue').textContent = e.target.value;
    });

    document.getElementById('lightR').addEventListener('input', function(e) {
        light1Color[0] = parseFloat(e.target.value);
        document.getElementById('lightRValue').textContent = e.target.value;
    });

    document.getElementById('lightG').addEventListener('input', function(e) {
        light1Color[1] = parseFloat(e.target.value);
        document.getElementById('lightGValue').textContent = e.target.value;
    });

    document.getElementById('lightB').addEventListener('input', function(e) {
        light1Color[2] = parseFloat(e.target.value);
        document.getElementById('lightBValue').textContent = e.target.value;
    });
}

</script>

</head>

<body onload="main();">

<h1>WebGL Scene: Sphere, Cone, and Cylinder with Advanced Lighting</h1>

<canvas id="webgl" width="800" height="600"></canvas>


<div class="controls">
    <h3>Light 1 Position Controls</h3>
    <div class="control-group">
        <label>X Position:</label>
        <input type="range" id="lightX" min="-5" max="5" step="0.1" value="2">
        <span class="value" id="lightXValue">2.0</span>
    </div>
    <div class="control-group">
        <label>Y Position:</label>
        <input type="range" id="lightY" min="-5" max="5" step="0.1" value="2">
        <span class="value" id="lightYValue">2.0</span>
    </div>
    <div class="control-group">
        <label>Z Position:</label>
        <input type="range" id="lightZ" min="-5" max="5" step="0.1" value="2">
        <span class="value" id="lightZValue">2.0</span>
    </div>
</div>

<div class="controls">
    <h3>Light 1 Color Controls</h3>
    <div class="control-group">
        <label>Red:</label>
        <input type="range" id="lightR" min="0" max="1" step="0.1" value="1">
        <span class="value" id="lightRValue">1.0</span>
    </div>
    <div class="control-group">
        <label>Green:</label>
        <input type="range" id="lightG" min="0" max="1" step="0.1" value="1">
        <span class="value" id="lightGValue">1.0</span>
    </div>
    <div class="control-group">
        <label>Blue:</label>
        <input type="range" id="lightB" min="0" max="1" step="0.1" value="1">
        <span class="value" id="lightBValue">1.0</span>
    </div>
</div>

<br> 

</body>
</html>
